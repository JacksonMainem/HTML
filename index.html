<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Infix to Prefix Converter</title>
<style>
body {
    font-family: Arial, sans-serif;
    background: #f2f2f2;
    padding: 30px;
}
input, button {
    width: 100%;
    padding: 10px;
    font-size: 16px;
    margin-top: 10px;
}
#result, #reverse, #paren {
    margin-top: 15px;
    font-weight: bold;
}
table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
}
th, td {
    border: 1px solid #333;
    padding: 8px;
    text-align: center;
}
th {
    background: #ddd;
}
</style>
</head>
<body>

<h2>Infix to Prefix Converter</h2>

<input type="text" id="infix" placeholder="Enter Infix Expression (e.g., A+B*C-D/E)">
<button onclick="convert()">Convert</button>

<div id="result"></div>
<div id="reverse"></div>
<div id="paren"></div>
<div id="table"></div>

<script>
// ========== OPERATOR UTILS ==========
function precedence(c) {
    if (c === '+' || c === '-') return 1;
    if (c === '*' || c === '/' || c === '%') return 2;
    if (c === '^') return 3;
    return -1;
}
function isOperator(c) {
    return "+-*/^%".includes(c);
}

// ========== VALIDATION ==========
function validateInfix(exp) {
    exp = exp.trim();
    if (!exp) return { valid:false, message:"❌ Please enter an expression" };
    if (isOperator(exp[0])) return { valid:false, message:"❌ Cannot start with operator" };
    if (isOperator(exp[exp.length-1])) return { valid:false, message:"❌ Cannot end with operator" };

    let lastWasOperator = true;
    let hasOperator = false;

    for (let i = 0; i < exp.length; i++) {
        let c = exp[i];
        if (c === ' ') continue;
        if (/[A-Z]/.test(c)) {
            if (i > 0 && /[A-Z]/.test(exp[i-1]))
                return { valid:false, message:"❌ Multi-letter operands not allowed" };
            if (!lastWasOperator)
                return { valid:false, message:"❌ Two operands together not allowed" };
            lastWasOperator = false;
        }
        else if (/[a-z]/.test(c))
            return { valid:false, message:"❌ Lowercase letters not allowed" };
        else if (/[0-9]/.test(c))
            return { valid:false, message:"❌ Numbers are not allowed" };
        else if (isOperator(c)) {
            if (lastWasOperator)
                return { valid:false, message:"❌ Two operators together not allowed" };
            lastWasOperator = true;
            hasOperator = true;
        }
        else if (c === '(' || c === ')') {
            lastWasOperator = (c === '(');
        }
        else
            return { valid:false, message:"❌ Invalid character detected" };
    }

    if (!hasOperator)
        return { valid:false, message:"❌ Expression must contain at least one operator" };

    return { valid:true };
}

// ========== INFIX → POSTFIX WITH STEPS & /symbol ==========
function infixToPostfixWithSteps(exp) {
    let stack = [];
    let output = "";
    let steps = [];

    function snapshot(poppedIndex=-1) {
        return stack.map((v,i)=>i===poppedIndex ? "/" + v : v).join(" ");
    }

    for (let c of exp) {
        if (c === ' ') continue;
        if (/[A-Z]/.test(c)) {
            output += c;
        }
        else if (c === '(') {
            stack.push(c);
        }
        else if (c === ')') {
            while (stack.length && stack[stack.length-1]!=='(') {
                let idx = stack.length-1;
                steps.push({symbol: stack[idx], stack: snapshot(idx), output});
                output += stack.pop();
            }
            let idx = stack.length-1;
            steps.push({symbol: '(', stack: snapshot(idx), output});
            stack.pop();
        }
        else if (isOperator(c)) {
            while (stack.length && precedence(c) <= precedence(stack[stack.length-1])) {
                let idx = stack.length-1;
                steps.push({symbol: stack[idx], stack: snapshot(idx), output});
                output += stack.pop();
            }
            stack.push(c);
        }
        steps.push({symbol:c, stack:stack.join(" "), output});
    }

    while(stack.length) {
        let idx = stack.length-1;
        steps.push({symbol: stack[idx], stack: snapshot(idx), output});
        output += stack.pop();
    }

    return {postfix: output, steps};
}

// ========== ADD AUTOMATIC PARENTHESES ==========
function addParentheses(exp) {
    let stack = [];
    let output = [];
    for(let c of exp){
        if(/[A-Z]/.test(c)) output.push(c);
        else if(isOperator(c)){
            let b = output.pop();
            let a = output.pop();
            output.push('(' + a + c + b + ')');
        }
    }
    return output[0]; // final expression with parentheses
}

// ========== INFIX → PREFIX ==========
function infixToPrefix(infix){
    let reversed = infix.split('').reverse().join('');
    reversed = reversed.replace(/\(/g,'#').replace(/\)/g,'(').replace(/#/g,')');

    let result = infixToPostfixWithSteps(reversed);
    let prefix = result.postfix.split('').reverse().join('');

    // generate auto parentheses version
    let autoParen = addParentheses(result.postfix.split('').reverse().join(''));
    return {postfix: result.postfix, prefix, steps: result.steps, autoParen};
}

// ========== RUN ==========
function convert(){
    let infix = document.getElementById("infix").value;
    let validation = validateInfix(infix);

    if(!validation.valid){
        document.getElementById("result").innerText = validation.message;
        document.getElementById("reverse").innerText = "";
        document.getElementById("paren").innerText = "";
        document.getElementById("table").innerHTML = "";
        return;
    }

    let result = infixToPrefix(infix);

    document.getElementById("result").innerText = "Prefix Expression: " + result.prefix;
    document.getElementById("paren").innerText = "Auto Parentheses Version: " + result.autoParen;

    let html = "<table><tr><th>Symbol</th><th>Stack</th><th>Output</th></tr>";
    for(let step of result.steps){
        html += `<tr>
                    <td>${step.symbol}</td>
                    <td>${step.stack}</td>
                    <td>${step.output}</td>
                 </tr>`;
    }
    html += "</table>";

    document.getElementById("table").innerHTML = html;
}
</script>

</body>
</html>
