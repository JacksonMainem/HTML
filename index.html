<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Infix to Prefix Converter with Auto Parentheses</title>
<style>
body {
    font-family: Arial, sans-serif;
    background: #f2f2f2;
    padding: 30px;
}
input, button {
    width: 100%;
    padding: 10px;
    font-size: 16px;
    margin-top: 10px;
}
#result, #reverse, #paren {
    margin-top: 15px;
    font-weight: bold;
}
table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
}
th, td {
    border: 1px solid #333;
    padding: 8px;
    text-align: center;
}
th {
    background: #ddd;
}
</style>
</head>
<body>

<h2>Infix to Prefix Converter with Auto-Parentheses</h2>

<input type="text" id="infix" placeholder="Enter Infix Expression (e.g., A+B*C-D/E)">
<button onclick="convert()">Convert</button>

<div id="result"></div>
<div id="paren"></div>
<div id="table"></div>

<script>
// =================== UTILITIES ===================
function precedence(c){
    if(c==='+'||c==='-') return 1;
    if(c==='*'||c==='/'||c==='%') return 2;
    if(c==='^') return 3;
    return -1;
}
function isOperator(c){
    return "+-*/^%".includes(c);
}

// =================== VALIDATION ===================
function validateInfix(exp){
    exp = exp.trim();
    if(!exp) return {valid:false,message:"❌ Please enter an expression"};
    if(isOperator(exp[0])) return {valid:false,message:"❌ Cannot start with operator"};
    if(isOperator(exp[exp.length-1])) return {valid:false,message:"❌ Cannot end with operator"};

    let lastWasOperator=true;
    let hasOperator=false;

    for(let i=0;i<exp.length;i++){
        let c=exp[i];
        if(c===' ') continue;
        if(/[A-Z]/.test(c)){
            if(i>0&&/[A-Z]/.test(exp[i-1])) return {valid:false,message:"❌ Multi-letter operands not allowed"};
            if(!lastWasOperator) return {valid:false,message:"❌ Two operands together not allowed"};
            lastWasOperator=false;
        }
        else if(/[a-z]/.test(c)) return {valid:false,message:"❌ Lowercase letters not allowed"};
        else if(/[0-9]/.test(c)) return {valid:false,message:"❌ Numbers not allowed"};
        else if(isOperator(c)){
            if(lastWasOperator) return {valid:false,message:"❌ Two operators together not allowed"};
            lastWasOperator=true;
            hasOperator=true;
        }
        else if(c==='('||c===')') lastWasOperator=(c==='(');
        else return {valid:false,message:"❌ Invalid character detected"};
    }

    if(!hasOperator) return {valid:false,message:"❌ Expression must contain at least one operator"};
    return {valid:true};
}

// =================== AUTO-PARENTHESES ===================
// Fully parenthesize infix expression based on PEMDAS
function autoParenthesize(exp){
    let stack=[]; // will hold subexpressions
    for(let c of exp){
        if(/[A-Z]/.test(c)) stack.push(c);
        else if(isOperator(c)){
            let b=stack.pop();
            let a=stack.pop();
            stack.push('('+a+c+b+')');
        }
    }
    return stack[0]; // fully parenthesized expression
}

// =================== INFIX → POSTFIX WITH STEPS ===================
function infixToPostfixWithSteps(exp){
    let stack=[];
    let output="";
    let steps=[];

    function snapshot(poppedIndex=-1){
        return stack.map((v,i)=>i===poppedIndex?"/"+v:v).join(" ");
    }

    for(let c of exp){
        if(c===' ') continue;
        if(/[A-Z]/.test(c)) output+=c;
        else if(c==='(') stack.push(c);
        else if(c===')'){
            while(stack.length&&stack[stack.length-1]!=='('){
                let idx=stack.length-1;
                steps.push({symbol:stack[idx],stack:snapshot(idx),output});
                output+=stack.pop();
            }
            let idx=stack.length-1;
            steps.push({symbol:'(',stack:snapshot(idx),output});
            stack.pop();
        }
        else if(isOperator(c)){
            while(stack.length&&precedence(c)<=precedence(stack[stack.length-1])){
                let idx=stack.length-1;
                steps.push({symbol:stack[idx],stack:snapshot(idx),output});
                output+=stack.pop();
            }
            stack.push(c);
        }
        steps.push({symbol:c,stack:stack.join(" "),output});
    }

    while(stack.length){
        let idx=stack.length-1;
        steps.push({symbol:stack[idx],stack:snapshot(idx),output});
        output+=stack.pop();
    }

    return {postfix:output,steps};
}

// =================== INFIX → PREFIX ===================
function infixToPrefix(infix){
    // Add parentheses automatically if missing
    let fullyParen=autoParenthesize(infix.replace(/\(/g,'').replace(/\)/g,'')); // remove user parens, auto add
    let reversed=fullyParen.split('').reverse().join('');
    reversed=reversed.replace(/\(/g,'#').replace(/\)/g,'(').replace(/#/g,')');

    let result=infixToPostfixWithSteps(reversed);
    let prefix=result.postfix.split('').reverse().join('');

    return {prefix,prefixWithParen:fullyParen,steps:result.steps};
}

// =================== RUN ===================
function convert(){
    let infix=document.getElementById("infix").value;
    let v=validateInfix(infix);

    if(!v.valid){
        document.getElementById("result").innerText=v.message;
        document.getElementById("paren").innerText="";
        document.getElementById("table").innerHTML="";
        return;
    }

    let res=infixToPrefix(infix);

    document.getElementById("result").innerText="Prefix Expression: "+res.prefix;
    document.getElementById("paren").innerText="Auto Parentheses Version: "+res.prefixWithParen;

    let html="<table><tr><th>Symbol</th><th>Stack</th><th>Output</th></tr>";
    for(let s of res.steps){
        html+=`<tr><td>${s.symbol}</td><td>${s.stack}</td><td>${s.output}</td></tr>`;
    }
    html+="</table>";
    document.getElementById("table").innerHTML=html;
}
</script>

</body>
</html>
