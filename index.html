<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Infix to Prefix Converter</title>
<style>
body {
    font-family: Arial, sans-serif;
    background: #f2f2f2;
    padding: 30px;
}
input, button {
    width: 100%;
    padding: 10px;
    font-size: 16px;
    margin-top: 10px;
}
#result, #reverse {
    margin-top: 15px;
    font-weight: bold;
}
table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
}
th, td {
    border: 1px solid #333;
    padding: 8px;
    text-align: center;
}
th {
    background: #ddd;
}
</style>
</head>
<body>

<h2>Infix to Prefix Converter</h2>

<input type="text" id="infix" placeholder="Enter Infix Expression (e.g., A+(B*C))">
<button onclick="convert()">Convert</button>

<div id="result"></div>
<div id="reverse"></div>
<div id="table"></div>

<script>
// ========= OPERATOR UTILS =========
function precedence(c) {
    if (c === '+' || c === '-') return 1;
    if (c === '*' || c === '/' || c === '%') return 2;
    if (c === '^') return 3;
    return -1;
}
function isOperator(c) {
    return "+-*/^%".includes(c);
}

// ========= VALIDATION (unchanged logic) =========
function validateInfix(exp) {
    exp = exp.trim();
    if (!exp) return { valid:false, message:"❌ Please enter an expression" };
    if (isOperator(exp[0])) return { valid:false, message:"❌ Cannot start with operator" };
    if (isOperator(exp[exp.length-1])) return { valid:false, message:"❌ Cannot end with operator" };

    let stack = [];
    let lastWasOperator = true;
    let hasOperator = false;
    let operatorCount = 0;
    let hasParen = false;

    for (let i = 0; i < exp.length; i++) {
        let c = exp[i];
        if (c === ' ') continue;

        if (/[A-Z]/.test(c)) {
            if (i > 0 && /[A-Z]/.test(exp[i-1]))
                return { valid:false, message:"❌ Multi-letter operands not allowed" };
            if (!lastWasOperator)
                return { valid:false, message:"❌ Two operands together" };
            lastWasOperator = false;
        }
        else if (/[a-z]/.test(c))
            return { valid:false, message:"❌ Lowercase letters not allowed" };
        else if (/[0-9]/.test(c))
            return { valid:false, message:"❌ Numbers not allowed" };
        else if (isOperator(c)) {
            if (lastWasOperator)
                return { valid:false, message:"❌ Two operators together" };
            lastWasOperator = true;
            hasOperator = true;
            operatorCount++;
        }
        else if (c === '(') {
            stack.push(c);
            hasParen = true;
            lastWasOperator = true;
        }
        else if (c === ')') {
            if (!stack.length)
                return { valid:false, message:"❌ Unbalanced parentheses" };
            stack.pop();
            lastWasOperator = false;
        }
        else
            return { valid:false, message:"❌ Invalid character" };
    }

    if (stack.length) return { valid:false, message:"❌ Unbalanced parentheses" };
    if (!hasOperator) return { valid:false, message:"❌ No operator found" };
    if (operatorCount >= 2 && !hasParen)
        return { valid:false, message:"❌ Parentheses required for 2+ operators" };

    return { valid:true };
}

// ========= INFIX → POSTFIX (FIXED VISUAL POP) =========
function infixToPostfixWithSteps(exp) {
    let stack = [];
    let output = "";
    let steps = [];

    function snapshot(poppedIndex = -1) {
        return stack.map((v, i) =>
            i === poppedIndex ? "/" + v : v
        ).join(" ");
    }

    for (let c of exp) {
        if (c === ' ') continue;

        if (/[A-Z]/.test(c)) {
            output += c;
            steps.push({ symbol: c, stack: snapshot(), output });
        }
        else if (c === '(') {
            stack.push(c);
            steps.push({ symbol: c, stack: snapshot(), output });
        }
        else if (c === ')') {
            while (stack.length && stack[stack.length-1] !== '(') {
                let idx = stack.length - 1;
                steps.push({ symbol: stack[idx], stack: snapshot(idx), output });
                output += stack.pop();
            }
            let idx = stack.length - 1;
            steps.push({ symbol: "(", stack: snapshot(idx), output });
            stack.pop(); // remove '('
        }
        else if (isOperator(c)) {
            while (stack.length &&
                   precedence(c) <= precedence(stack[stack.length-1])) {
                let idx = stack.length - 1;
                steps.push({ symbol: stack[idx], stack: snapshot(idx), output });
                output += stack.pop();
            }
            stack.push(c);
            steps.push({ symbol: c, stack: snapshot(), output });
        }
    }

    while (stack.length) {
        let idx = stack.length - 1;
        steps.push({ symbol: stack[idx], stack: snapshot(idx), output });
        output += stack.pop();
    }

    return { postfix: output, steps };
}

// ========= INFIX → PREFIX =========
function infixToPrefix(infix) {
    let reversed = infix.split('').reverse().join('');
    reversed = reversed.replace(/\(/g,'#').replace(/\)/g,'(').replace(/#/g,')');

    let result = infixToPostfixWithSteps(reversed);
    return {
        postfix: result.postfix,
        prefix: result.postfix.split('').reverse().join(''),
        steps: result.steps
    };
}

// ========= RUN =========
function convert() {
    let infix = document.getElementById("infix").value;
    let v = validateInfix(infix);

    if (!v.valid) {
        document.getElementById("result").innerText = v.message;
        document.getElementById("reverse").innerText = "";
        document.getElementById("table").innerHTML = "";
        return;
    }

    let r = infixToPrefix(infix);

    document.getElementById("result").innerText =
        "Postfix (from reversed infix): " + r.postfix;

    document.getElementById("reverse").innerText =
        "Final Prefix Expression: " + r.prefix;

    let html = "<table><tr><th>Symbol</th><th>Stack</th><th>Output</th></tr>";
    for (let s of r.steps) {
        html += `<tr><td>${s.symbol}</td><td>${s.stack}</td><td>${s.output}</td></tr>`;
    }
    html += "</table>";
    document.getElementById("table").innerHTML = html;
}
</script>

</body>
</html>        document.getElementById("table").innerHTML = "";
        return;
    }

    let result = infixToPrefix(infix);

    document.getElementById("result").innerText =
        "Postfix (from reversed infix): " + result.postfix;

    document.getElementById("reverse").innerText =
        "Final Prefix Expression: " + result.prefix;

    let html = "<table><tr><th>Symbol</th><th>Stack</th><th>Output</th></tr>";
    for (let step of result.steps) {
        html += `<tr>
                    <td>${step.symbol}</td>
                    <td>${step.stack}</td>
                    <td>${step.output}</td>
                 </tr>`;
    }
    html += "</table>";

    document.getElementById("table").innerHTML = html;
}
</script>

</body>
</html>
