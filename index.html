<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Infix to Prefix Converter</title>
<style>
body {
    font-family: Arial, sans-serif;
    background: #f2f2f2;
    padding: 30px;
}
input, button {
    width: 100%;
    padding: 10px;
    font-size: 16px;
    margin-top: 10px;
}
#result {
    margin-top: 15px;
    font-weight: bold;
}
</style>
</head>
<body>

<h2>Infix to Prefix Converter</h2>

<input type="text" id="infix" placeholder="Enter Infix Expression (e.g., A+(B*C))">
<button onclick="convert()">Convert</button>

<div id="result"></div>

<script>
// ================= OPERATORS =================
function precedence(c) {
    switch(c) {
        case '+': case '-': return 1;
        case '*': case '/': case '%': return 2;
        case '^': return 3;
    }
    return -1;
}

function isOperator(c) {
    return "+-*/^%".includes(c);
}

// ================= VALIDATION =================
function validateInfix(exp) {
    exp = exp.trim();
    if (!exp)
        return { valid:false, message:"❌ Please enter an expression" };

    // Cannot start with operator
    if (isOperator(exp[0]))
        return { valid:false, message:"❌ Invalid infix: cannot start with an operator" };

    // Cannot end with operator
    if (isOperator(exp[exp.length - 1]))
        return { valid:false, message:"❌ Invalid expression: incomplete infix (operator at end)" };

    // Count operators & parentheses
    let operatorCount = 0;
    let hasParentheses = false;

    for (let c of exp) {
        if (isOperator(c)) operatorCount++;
        if (c === '(' || c === ')') hasParentheses = true;
    }

    // Parentheses required if 2 or more operators
    if (operatorCount >= 2 && !hasParentheses)
        return { valid:false, message:"❌ Parentheses are required when using two or more operators" };

    let stack = [];
    let lastWasOperator = true;
    let hasOperator = false;

    for (let i = 0; i < exp.length; i++) {
        let c = exp[i];

        if (c === ' ') continue;

        if (/[A-Z]/.test(c)) {
            if (i > 0 && /[A-Z]/.test(exp[i - 1]))
                return { valid:false, message:"❌ Multi-letter operands are not allowed" };

            if (!lastWasOperator)
                return { valid:false, message:"❌ Invalid infix: two operands in a row" };

            lastWasOperator = false;
        }
        else if (/[a-z]/.test(c)) {
            return { valid:false, message:"❌ Lowercase letters are not allowed" };
        }
        else if (/[0-9]/.test(c)) {
            return { valid:false, message:"❌ Numbers are not allowed" };
        }
        else if (isOperator(c)) {
            if (lastWasOperator)
                return { valid:false, message:"❌ Invalid infix: two operators cannot be together" };

            lastWasOperator = true;
            hasOperator = true;
        }
        else if (c === '(') {
            if (!lastWasOperator)
                return { valid:false, message:"❌ Invalid infix: '(' must follow an operator" };

            stack.push(c);
            lastWasOperator = true;
        }
        else if (c === ')') {
            if (stack.length === 0)
                return { valid:false, message:"❌ Parentheses are not balanced" };

            stack.pop();
            lastWasOperator = false;
        }
        else {
            return { valid:false, message:"❌ Invalid character detected" };
        }
    }

    if (stack.length > 0)
        return { valid:false, message:"❌ Parentheses are not balanced" };

    if (!hasOperator)
        return { valid:false, message:"❌ Expression must include at least one operator" };

    return { valid:true };
}

// INFIX → POSTFIX
function infixToPostfix(exp) {
    let stack = [];
    let result = "";

    for (let c of exp) {
        if (/[A-Z]/.test(c)) {
            result += c;
        }
        else if (c === '(') {
            stack.push(c);
        }
        else if (c === ')') {
            while (stack.length && stack[stack.length - 1] !== '(')
                result += stack.pop();
            stack.pop();
        }
        else if (isOperator(c)) {
            while (stack.length &&
                   precedence(c) <= precedence(stack[stack.length - 1]))
                result += stack.pop();
            stack.push(c);
        }
    }

    while (stack.length)
        result += stack.pop();

    return result;
}

// INFIX → PREFIX 
function infixToPrefix(infix) {
    let validation = validateInfix(infix);
    if (!validation.valid) return validation.message;

    let rev = infix.split('').reverse().join('');
    rev = rev.replace(/\(/g,'#').replace(/\)/g,'(').replace(/#/g,')');

    let postfix = infixToPostfix(rev);

    return postfix.split('').reverse().join('');
}

// RUN 
function convert() {
    let infix = document.getElementById("infix").value;
    let result = infixToPrefix(infix);
    document.getElementById("result").innerText = result.startsWith("❌")
        ? result
        : "Prefix Expression: " + result;
}
</script>

</body>
</html></html>
