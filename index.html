<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Infix to Prefix Converter</title>
<style>
body {
    font-family: Arial, sans-serif;
    background: #f2f2f2;
    padding: 30px;
}
input, button {
    width: 100%;
    padding: 10px;
    font-size: 16px;
    margin-top: 10px;
}
#result, #reverse {
    margin-top: 15px;
    font-weight: bold;
}
table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
}
th, td {
    border: 1px solid #333;
    padding: 8px;
    text-align: center;
}
th {
    background: #ddd;
}
</style>
</head>
<body>

<h2>Infix to Prefix Converter</h2>

<input type="text" id="infix" placeholder="Enter Infix Expression (e.g., A+(B*C))">
<button onclick="convert()">Convert</button>

<div id="result"></div>
<div id="reverse"></div>
<div id="table"></div>

<script>
// ================= OPERATORS =================
function precedence(c) {
    if (c === '+' || c === '-') return 1;
    if (c === '*' || c === '/' || c === '%') return 2;
    if (c === '^') return 3;
    return -1;
}

function isOperator(c) {
    return "+-*/^%".includes(c);
}

// ================= VALIDATION =================
function validateInfix(exp) {
    exp = exp.trim();
    if (!exp) return { valid:false, message:"❌ Please enter an expression" };
    if (isOperator(exp[0])) return { valid:false, message:"❌ Invalid infix: cannot start with an operator" };
    if (isOperator(exp[exp.length-1])) return { valid:false, message:"❌ Invalid infix: cannot end with an operator" };

    let operatorCount = 0;
    let hasParen = false;
    let stack = [];
    let lastWasOperator = true;
    let hasOperator = false;

    for (let i = 0; i < exp.length; i++) {
        let c = exp[i];
        if (c === ' ') continue;

        if (/[A-Z]/.test(c)) {
            if (i > 0 && /[A-Z]/.test(exp[i-1]))
                return { valid:false, message:"❌ Multi-letter operands are not allowed" };
            if (!lastWasOperator)
                return { valid:false, message:"❌ Two operands together not allowed" };
            lastWasOperator = false;
        }
        else if (/[a-z]/.test(c))
            return { valid:false, message:"❌ Lowercase letters are not allowed" };
        else if (/[0-9]/.test(c))
            return { valid:false, message:"❌ Numbers are not allowed" };
        else if (isOperator(c)) {
            if (lastWasOperator)
                return { valid:false, message:"❌ Two operators together not allowed" };
            lastWasOperator = true;
            hasOperator = true;
            operatorCount++;
        }
        else if (c === '(') {
            stack.push(c);
            hasParen = true;
            lastWasOperator = true;
        }
        else if (c === ')') {
            if (stack.length === 0)
                return { valid:false, message:"❌ Parentheses are not balanced" };
            stack.pop();
            lastWasOperator = false;
        }
        else
            return { valid:false, message:"❌ Invalid character detected" };
    }

    if (stack.length > 0)
        return { valid:false, message:"❌ Parentheses are not balanced" };
    if (!hasOperator)
        return { valid:false, message:"❌ Expression must contain at least one operator" };
    if (operatorCount >= 2 && !hasParen)
        return { valid:false, message:"❌ Parentheses are required when using two or more operators" };

    return { valid:true };
}

// ================= INFIX → POSTFIX (WITH STEPS) =================
function infixToPostfixWithSteps(exp) {
    let stack = [];
    let output = "";
    let steps = [];

    for (let c of exp) {
        if (c === ' ') continue;

        if (/[A-Z]/.test(c)) {
            output += c;
        }
        else if (c === '(') {
            stack.push(c);
        }
        else if (c === ')') {
            while (stack.length && stack[stack.length-1] !== '(')
                output += stack.pop();
            stack.pop();
        }
        else if (isOperator(c)) {
            while (stack.length &&
                   precedence(c) <= precedence(stack[stack.length-1]))
                output += stack.pop();
            stack.push(c);
        }

        steps.push({
            symbol: c,
            stack: stack.join(" "),
            output: output
        });
    }

    while (stack.length) {
        output += stack.pop();
        steps.push({
            symbol: "POP",
            stack: stack.join(" "),
            output: output
        });
    }

    return { postfix: output, steps };
}

// ================= INFIX → PREFIX =================
function infixToPrefix(infix) {
    let reversed = infix.split('').reverse().join('');
    reversed = reversed.replace(/\(/g,'#').replace(/\)/g,'(').replace(/#/g,')');

    let result = infixToPostfixWithSteps(reversed);

    let prefix = result.postfix.split('').reverse().join('');

    return {
        postfix: result.postfix,
        prefix: prefix,
        steps: result.steps
    };
}

// ================= RUN =================
function convert() {
    let infix = document.getElementById("infix").value;
    let validation = validateInfix(infix);

    if (!validation.valid) {
        document.getElementById("result").innerText = validation.message;
        document.getElementById("reverse").innerText = "";
        document.getElementById("table").innerHTML = "";
        return;
    }

    let result = infixToPrefix(infix);

    document.getElementById("result").innerText =
        "Postfix (from reversed infix): " + result.postfix;

    document.getElementById("reverse").innerText =
        "Final Prefix Expression (Reversed Output): " + result.prefix;

    let html = "<table><tr><th>Symbol</th><th>Stack</th><th>Output</th></tr>";
    for (let step of result.steps) {
        html += `<tr>
                    <td>${step.symbol}</td>
                    <td>${step.stack}</td>
                    <td>${step.output}</td>
                 </tr>`;
    }
    html += "</table>";

    document.getElementById("table").innerHTML = html;
}
</script>

</body>
</html>
